---
title: 字符串匹配基础（下）
date: 2020-09-11 11:03:04
tags:
- 基础篇
- 数据结构与算法
categories:
- 数据结构与算法
---

借助BM算法理解KMP算法

<!-- more -->

### KMP 算法基本原理

![](da99c0349f8fac27e193af8d801dbb8f.jpg)

我们只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的。假设最长的可匹配的那部分前缀子串是{v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k，i 不变，然后继续比较。



为了表述起来方便，我把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作***最长可匹配后缀子串***；对应的前缀子串，叫作***最长可匹配前缀子串***。

![](9e59c0973ffb965abdd3be5eafb492ad.jpg)

KMP匹配过程中可以不需要主串，可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。我们把这个数组定义为 ***next*** 数组，很多书中还给这个数组起了一个名字，叫***失效函数（failure function）***。



数组的下标是每个前缀结尾字符下标，***数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标***。

![](1661d37cb190cb83d713749ff9feaea8.jpg)

