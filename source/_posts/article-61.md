---
title: 贪心算法
date: 2020-09-14 12:04:24
tags:
- 基础篇
- 数据结构与算法
categories:
- 数据结构与算法
---

用贪心算法实现Huffman压缩编码

<!-- more -->

### 如何理解“贪心算法”？

针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大。每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。

但是实际上，用贪心算法解决问题的思路，并不总能给出最优解。

### 贪心算法实战分析

#### 分糖果

我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m<n），所以糖果只能分配给一部分孩子。如何分配糖果，能尽可能满足最多数量的孩子？

方案是：首先将孩子对糖果大小的需求排序，得到：g1 <= g2 <= g3，...； 再对糖果的大小进行排序：s1 <= s2 <= s3 ...; 从g1开始遍历所有的g，找能够满足大于等于g的最小的糖果；由此，被满足的孩子个数是最多的。

#### 钱币找零

假设我们有 1 元、2 元、5 元、10 元、20 元、50 元、100 元这些面额的纸币，它们的张数分别是 c1、c2、c5、c10、c20、c50、c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？

方案是：先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。

#### 区间覆盖

假设我们有 n 个区间，区间的起始端点和结束端点分别是[l1, r1]，[l2, r2]，[l3, r3]，……，[ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交（端点相交的情况不算相交），最多能选出多少个区间呢？

![](f0a1b7978711651d9f084d19a70805cd.jpg)

解决思路：我们假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将[lmin, rmax]覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。我们每次选择的时候，左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法。

![](ef2d0bd8284cb6e69294566a45b0e2b5.jpg)

### 霍夫曼编码

霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。如何给不同频率的字符选择不同长度的编码呢？根据贪心的思想，我们可以把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码。对于等长的编码来说，我们解压缩起来很简单。但是，霍夫曼编码是不等长的，每次应该读取 1 位还是 2 位、3 位等等来解压缩呢？这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况。



假设这 6 个字符出现的频率从高到低依次是 a、b、c、d、e、f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了。

![](83921e609c8a4dc81ca5b90c8b4cd745.jpg)



#### 如何根据字符出现频率的不同，给不同的字符进行不同长度的编码

我们把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A、B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A、B 的父节点。最后再把 C 节点放入到优先级队列中。重复这个过程，直到队列中没有数据。

![](7b6a08e7df45eac66820b959c64f877a.jpg)

现在，我们给每一条边加上画一个权值，指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码。

![](ccf15d048be005924a409574dce143ed.jpg)

### 总结

贪心算法适用的场景比较有限。这种算法思想更多的是指导设计基础算法。比如最小生成树算法、单源最短路径算法，这些算法都用到了贪心算法。



### 思考

#### 在一个非负整数 a 中，我们希望从中移除 k 个数字，让剩下的数字值最小，如何选择移除哪 k 个数字呢？

由高位开始两两比较大小，若高位大，低位小，则删除高位；反之右移一位。循环k次。

#### 假设有 n 个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同的，如何安排被服务的先后顺序，才能让这 n 个人总的等待时间最短？

前面的被服务时间会影响，后面的被服务时间；总时间是后面的时间加上前面的时间和，所以，从服务时间最少的开始服务。

