<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"onlygodsee.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="太液池">
<meta property="og:url" content="http://onlygodsee.github.io/index.html">
<meta property="og:site_name" content="太液池">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="涧石">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://onlygodsee.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>太液池</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?02189f42c1a6b074aac7e82ae5ba1f4b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">太液池</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlygodsee.github.io/2020/09/02/article-45/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog_head.png">
      <meta itemprop="name" content="涧石">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="太液池">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/article-45/" class="post-title-link" itemprop="url">散列表（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-02 19:49:40" itemprop="dateCreated datePublished" datetime="2020-09-02T19:49:40+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 17:03:02" itemprop="dateModified" datetime="2020-09-03T17:03:02+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="散列表和链表一起使用"><a href="#散列表和链表一起使用" class="headerlink" title="散列表和链表一起使用"></a>散列表和链表一起使用</h2><p><img src="eaefd5f4028cc7d4cfbb56b24ce8ae6e.jpg" alt=""></p>
<p>我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 hnext。这个 hnext 有什么作用呢？因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链。<strong><em>前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中。</em></strong></p>
<h3 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h3><h4 id="查找一个数据"><a href="#查找一个数据" class="headerlink" title="查找一个数据"></a>查找一个数据</h4><p>散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的尾部。</p>
<h4 id="删除一个数据"><a href="#删除一个数据" class="headerlink" title="删除一个数据"></a>删除一个数据</h4><p>借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。</p>
<h4 id="添加一个数据"><a href="#添加一个数据" class="headerlink" title="添加一个数据"></a>添加一个数据</h4><p>先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部。</p>
<h3 id="Redis-有序集合"><a href="#Redis-有序集合" class="headerlink" title="Redis 有序集合"></a>Redis 有序集合</h3><p>按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)。同时，借助跳表结构，其他操作也非常高效。</p>
<h3 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h3><p>LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。LinkedHashMap 中的“Linked”实际上是指的是双向链表，并非指用链表法解决散列冲突。</p>
<h3 id="为什么散列表和链表经常一块使用？"><a href="#为什么散列表和链表经常一块使用？" class="headerlink" title="为什么散列表和链表经常一块使用？"></a>为什么散列表和链表经常一块使用？</h3><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。</p>
<p>因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlygodsee.github.io/2020/09/02/article-44/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog_head.png">
      <meta itemprop="name" content="涧石">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="太液池">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/article-44/" class="post-title-link" itemprop="url">散列表（中）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-02 18:49:55" itemprop="dateCreated datePublished" datetime="2020-09-02T18:49:55+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 15:10:46" itemprop="dateModified" datetime="2020-09-03T15:10:46+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><h3 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h3><p>散列函数的设计不能太复杂，且散列函数生成的值要尽可能随机并且均匀分布。</p>
<p>常用方法：</p>
<p>数据分析法、直接寻址法、平方取中法、折叠法、随机数法等</p>
<h3 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h3><p>对装载因子设置阈值，来对散列表进行动态扩容与动态缩容。</p>
<p>装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p>
<h3 id="如何避免低效的扩容？"><a href="#如何避免低效的扩容？" class="headerlink" title="如何避免低效的扩容？"></a>如何避免低效的扩容？</h3><p>为了解决一次性扩容耗时过多的情况，我们可以将扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</p>
<h3 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h3><h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。</li>
<li>这种方法实现的散列表，序列化起来比较简单。</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。</li>
<li>所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。</li>
</ul>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>当数据量比较小、装载因子小的时候，适合采用开放寻址法。这也是 Java 中的ThreadLocalMap使用开放寻址法解决散列冲突的原因。</p>
<h4 id="链表法（拉链法）"><a href="#链表法（拉链法）" class="headerlink" title="链表法（拉链法）"></a>链表法（拉链法）</h4><h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>内存的利用率比开放寻址法要高</li>
<li>对大装载因子的容忍度更高</li>
</ul>
<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。</li>
<li>因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</li>
</ul>
<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p>
<h5 id="改造"><a href="#改造" class="headerlink" title="改造"></a>改造</h5><p>我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了前面讲到的散列碰撞攻击。</p>
<h3 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a>工业级散列表举例分析</h3><p>Java 中的 HashMap</p>
<h4 id="初始大小"><a href="#初始大小" class="headerlink" title="初始大小"></a>初始大小</h4><p>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的。</p>
<h4 id="装载因子和动态扩容"><a href="#装载因子和动态扩容" class="headerlink" title="装载因子和动态扩容"></a>装载因子和动态扩容</h4><p>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 0.75*capacity（capacity 表示散列表的容量）的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小。</p>
<h4 id="散列冲突解决方法"><a href="#散列冲突解决方法" class="headerlink" title="散列冲突解决方法"></a>散列冲突解决方法</h4><p>HashMap 底层采用链表法来解决冲突。即使负载因子和散列函数设计得再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响 HashMap 的性能。</p>
<p>于是，在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了<strong><em>红黑树</em></strong>。而当链表长度太长（<strong><em>默认超过 8</em></strong>）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。<strong><em>当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表</em></strong>。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显。</p>
<h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capicity -<span class="number">1</span>); <span class="comment">//capicity表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，hashCode() 返回的是 Java 对象的 hash code。比如 String 类型的对象的 hashCode() 就是下面这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> var1 = <span class="keyword">this</span>.hash;</span><br><span class="line">  <span class="keyword">if</span>(var1 == <span class="number">0</span> &amp;&amp; <span class="keyword">this</span>.value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] var2 = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; <span class="keyword">this</span>.value.length; ++var3) &#123;</span><br><span class="line">      var1 = <span class="number">31</span> * var1 + var2[var3];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.hash = var1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="在你熟悉的编程语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？"><a href="#在你熟悉的编程语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？" class="headerlink" title="在你熟悉的编程语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？"></a>在你熟悉的编程语言中，哪些数据类型底层是基于散列表实现的？散列函数是如何设计的？散列冲突是通过哪种方法解决的？是否支持动态扩容呢？</h3><p>比如Redis中的hash,set,hset,都是散列表实现，他们的动态扩容策略是同时维护两个散列表，然后一点点搬移数据</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlygodsee.github.io/2020/09/02/article-43/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog_head.png">
      <meta itemprop="name" content="涧石">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="太液池">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/article-43/" class="post-title-link" itemprop="url">散列表（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-02 16:23:34" itemprop="dateCreated datePublished" datetime="2020-09-02T16:23:34+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 15:10:46" itemprop="dateModified" datetime="2020-09-03T15:10:46+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h3 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h3><p>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</p>
<p>当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><h4 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h4><ul>
<li>散列函数计算得到的散列值是一个非负整数</li>
<li>如果 key1 = key2，那 hash(key1) == hash(key2)</li>
<li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)</li>
</ul>
<h3 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h3><p>解决方法有两类，开放寻址法（open addressing）和链表法（chaining）。</p>
<h4 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h4><p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<p>我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。</p>
<p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<strong><em>二次探测</em></strong>（Quadratic probing）和<strong><em>双重散列</em></strong>（Double hashing）。</p>
<p>为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用装载因子（load factor）来表示空位的多少。</p>
<p>装载因子的计算公式是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的装载因子&#x3D;填入表中的元素个数&#x2F;散列表的长度</span><br></pre></td></tr></table></figure>

<p><strong><em>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</em></strong></p>
<h4 id="链表法（拉链法）"><a href="#链表法（拉链法）" class="headerlink" title="链表法（拉链法）"></a>链表法（拉链法）</h4><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<p>对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中“槽”的个数。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="假设我们有-10-万条-URL-访问日志，如何按照访问次数给-URL-排序？"><a href="#假设我们有-10-万条-URL-访问日志，如何按照访问次数给-URL-排序？" class="headerlink" title="假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？"></a>假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</h4><p>遍历 10 万条数据，以 URL 为 key，访问次数为 value，存入散列表，同时记录下访问次数的最大值 K，时间复杂度 O(N)。</p>
<p>如果 K 不是很大，可以使用桶排序，时间复杂度 O(N)。如果 K 非常大（比如大于 10 万），就使用快速排序，复杂度 O(NlogN)。</p>
<h4 id="有两个字符串数组，每个数组大约有-10-万条字符串，如何快速找出两个数组中相同的字符串？"><a href="#有两个字符串数组，每个数组大约有-10-万条字符串，如何快速找出两个数组中相同的字符串？" class="headerlink" title="有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？"></a>有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</h4><p>以第一个字符串数组构建散列表，key 为字符串，value 为出现次数。再遍历第二个字符串数组，以字符串为 key 在散列表中查找，如果 value 大于零，说明存在相同字符串。时间复杂度 O(N)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlygodsee.github.io/2020/09/02/article-42/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog_head.png">
      <meta itemprop="name" content="涧石">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="太液池">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/article-42/" class="post-title-link" itemprop="url">二分查找（下）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-02 14:46:00" itemprop="dateCreated datePublished" datetime="2020-09-02T14:46:00+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 15:10:46" itemprop="dateModified" datetime="2020-09-03T15:10:46+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="查找第一个值等于给定值的元素-有序有重复数据"><a href="#查找第一个值等于给定值的元素-有序有重复数据" class="headerlink" title="查找第一个值等于给定值的元素(有序有重复数据)"></a>查找第一个值等于给定值的元素(有序有重复数据)</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arrays, val)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(arrays) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arrays[mid] &gt;= val:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (low &lt; len(arrays)) <span class="keyword">and</span> arrays[low] == val:</span><br><span class="line">        <span class="keyword">return</span> low</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arrays, val)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = len(arrays) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt; high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arrays[mid] &gt; val:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arrays[mid] &lt; val:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> arrays[mid<span class="number">-1</span>] != val:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="查找最后一个值等于给定值的元素"><a href="#查找最后一个值等于给定值的元素" class="headerlink" title="查找最后一个值等于给定值的元素"></a>查找最后一个值等于给定值的元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一种</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arrays, val)</span>:</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arrays[mid] &lt;= val:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> high &lt; length <span class="keyword">and</span> arrays[high] == val:</span><br><span class="line">        <span class="keyword">return</span> high</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arrays, val)</span>:</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arrays[mid] &gt; val:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> arrays[mid] &lt; val:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> (mid == (length<span class="number">-1</span>)) <span class="keyword">or</span> arrays[mid + <span class="number">1</span>] != val:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="查找第一个大于等于给定值的元素"><a href="#查找第一个大于等于给定值的元素" class="headerlink" title="查找第一个大于等于给定值的元素"></a>查找第一个大于等于给定值的元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arrays, val)</span>:</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arrays[mid] &gt;= val:</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> <span class="keyword">or</span> arrays[mid<span class="number">-1</span>] &lt; val:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="查找最后一个小于等于给定值的元素"><a href="#查找最后一个小于等于给定值的元素" class="headerlink" title="查找最后一个小于等于给定值的元素"></a>查找最后一个小于等于给定值的元素</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arrays, val)</span>:</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arrays[mid] &lt;= val:</span><br><span class="line">            <span class="keyword">if</span> mid == (length<span class="number">-1</span>) <span class="keyword">or</span> arrays[mid+<span class="number">1</span>] &gt; val:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="如果有序数组是一个循环有序数组，比如-4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？"><a href="#如果有序数组是一个循环有序数组，比如-4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？" class="headerlink" title="如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？"></a>如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arrays, val)</span>:</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = length - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high:</span><br><span class="line">        mid = low + ((high - low) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arrays[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arrays[mid] &gt; val:</span><br><span class="line">            <span class="comment"># 左半序列</span></span><br><span class="line">            <span class="keyword">if</span> arrays[low] &gt; val:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid - <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> arrays[high] &lt; val:</span><br><span class="line">                high = mid <span class="number">-1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlygodsee.github.io/2020/09/02/article-41/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog_head.png">
      <meta itemprop="name" content="涧石">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="太液池">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/02/article-41/" class="post-title-link" itemprop="url">二分查找（上）</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-02 09:37:00" itemprop="dateCreated datePublished" datetime="2020-09-02T09:37:00+08:00">2020-09-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 15:10:46" itemprop="dateModified" datetime="2020-09-03T15:10:46+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>时间复杂度O(logn)</p>
<h3 id="代码实现（有序数组无重复数据）"><a href="#代码实现（有序数组无重复数据）" class="headerlink" title="代码实现（有序数组无重复数据）"></a>代码实现（有序数组无重复数据）</h3><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search2</span><span class="params">(arrays, l, r, val)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt;= r:</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arrays[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> arrays[mid] &gt; val:</span><br><span class="line">            <span class="keyword">return</span> binary_search2(arrays, l, mid<span class="number">-1</span>, val)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> binary_search2(arrays, mid+<span class="number">1</span>, r, val)</span><br></pre></td></tr></table></figure>



<h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(arrays, val)</span>:</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = len(arrays)<span class="number">-1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> arrays[mid] == val:</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        <span class="keyword">if</span> arrays[mid] &lt; val:</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = mid</span><br></pre></td></tr></table></figure>



<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><h4 id="二分查找依赖的是顺序表结构，简单点说就是数组"><a href="#二分查找依赖的是顺序表结构，简单点说就是数组" class="headerlink" title="二分查找依赖的是顺序表结构，简单点说就是数组"></a>二分查找依赖的是顺序表结构，简单点说就是数组</h4><p>主要原因是二分查找算法需要按照下标随机访问元素</p>
<h4 id="二分查找针对的是有序数据"><a href="#二分查找针对的是有序数据" class="headerlink" title="二分查找针对的是有序数据"></a>二分查找针对的是有序数据</h4><p>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。</p>
<h4 id="数据量太小不适合二分查找"><a href="#数据量太小不适合二分查找" class="headerlink" title="数据量太小不适合二分查找"></a>数据量太小不适合二分查找</h4><p>有一个例外，如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。</p>
<h4 id="数据量太大也不适合二分查找"><a href="#数据量太大也不适合二分查找" class="headerlink" title="数据量太大也不适合二分查找"></a>数据量太大也不适合二分查找</h4><p>二分查找基于数组，而数组需要在连续的内存的空间。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="实现“求一个数的平方根”？要求精确到小数点后-6-位。"><a href="#实现“求一个数的平方根”？要求精确到小数点后-6-位。" class="headerlink" title="实现“求一个数的平方根”？要求精确到小数点后 6 位。"></a>实现“求一个数的平方根”？要求精确到小数点后 6 位。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_sqrt</span><span class="params">(num, s)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; <span class="number">1</span>:</span><br><span class="line">        low = <span class="number">1</span></span><br><span class="line">        hight = num</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        low = num</span><br><span class="line">        hight = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    line = <span class="number">1</span>/pow(<span class="number">10</span>, s)</span><br><span class="line">    <span class="keyword">while</span> low &lt; hight:</span><br><span class="line">        mid = (low + hight) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        val = mid * mid</span><br><span class="line">        <span class="keyword">if</span> abs(val - num) &lt;= line:</span><br><span class="line">            <span class="keyword">return</span> round(mid, s)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> val &gt; num:</span><br><span class="line">            hight = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            low = mid</span><br></pre></td></tr></table></figure>

<h4 id="如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？"><a href="#如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？" class="headerlink" title="如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？"></a>如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？</h4><p>假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异):<br>第一次查找中间点，需要移动指针n/2次；<br>第二次，需要移动指针n/4次；<br>第三次需要移动指针n/8次；<br>……<br>以此类推，一直到1次为值</p>
<p>总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + …+ 1，这显然是个等比数列，根据等比数列求和公式：Sum = n - 1.</p>
<p>最后算法时间复杂度是：O(n-1)，忽略常数，记为O(n)，时间复杂度和顺序查找时间复杂度相同</p>
<p>但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlygodsee.github.io/2020/09/01/article-40/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog_head.png">
      <meta itemprop="name" content="涧石">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="太液池">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/article-40/" class="post-title-link" itemprop="url">排序优化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-01 20:27:32" itemprop="dateCreated datePublished" datetime="2020-09-01T20:27:32+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 15:10:46" itemprop="dateModified" datetime="2020-09-03T15:10:46+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="排序优化"><a href="#排序优化" class="headerlink" title="排序优化"></a>排序优化</h2><h3 id="如何选择合适的排序算法？"><a href="#如何选择合适的排序算法？" class="headerlink" title="如何选择合适的排序算法？"></a>如何选择合适的排序算法？</h3><p><img src="/.io//1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg" alt></p>
<p>线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p>
<p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n^2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p>
<p>归并排序虽然时间复杂度是 O(nlogn) ，但并不是原地排序，需要消耗掉额外的空间，所以一般用快排来实现通用排序。</p>
<h3 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h3><p>当序列本身就是有序的，然后依然每次选择最后一个数据进行分区，此时时间复杂度就会退化为O(n^2)。所以快排的优化关键在于分区点选择的合理性。</p>
<p>最理想的分区点是：<strong><em>被分区点分开的两个分区中，数据的数量差不多</em></strong>。</p>
<p>下面介绍两个分区方法。</p>
<h4 id="三数取中法"><a href="#三数取中法" class="headerlink" title="三数取中法"></a>三数取中法</h4><p>我们从区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p>
<h4 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h4><p>随机法就是每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。</p>
<h3 id="快排如何避免栈溢出"><a href="#快排如何避免栈溢出" class="headerlink" title="快排如何避免栈溢出"></a>快排如何避免栈溢出</h3><ul>
<li>第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。</li>
<li>第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</li>
</ul>
<h3 id="快排一定是最优解吗？"><a href="#快排一定是最优解吗？" class="headerlink" title="快排一定是最优解吗？"></a>快排一定是最优解吗？</h3><p>排序算法需要根据使用场景选择，比如数据量小于4时，插入排序的效率就比快排更高，所以在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。</p>
<p>而当数据占用空间比较小时，归并排序也优于快排。</p>
<h3 id="Python的sorted排序使用什么方式实现"><a href="#Python的sorted排序使用什么方式实现" class="headerlink" title="Python的sorted排序使用什么方式实现"></a>Python的sorted排序使用什么方式实现</h3><p>Python的sorted使用了timsort排序。</p>
<p>timsort结合了归并排序和插入排序（二分插入算法）。</p>
<h4 id="Timsort核心过程"><a href="#Timsort核心过程" class="headerlink" title="Timsort核心过程"></a>Timsort核心过程</h4><p>TimSort 算法为了减少对升序部分的回溯和对降序部分的性能倒退，将输入按其升序和降序特点进行了分区。排序的输入的单位不是一个个单独的数字，而是一个个的块-分区。其中每一个分区叫一个run。针对这些 run 序列，每次拿一个 run 出来按规则进行合并。每次合并会将两个 run合并成一个 run。合并的结果保存到栈中。合并直到消耗掉所有的 run，这时将栈上剩余的 run合并到只剩一个 run 为止。这时这个仅剩的 run 便是排好序的结果。</p>
<ul>
<li>如何数组长度小于某个值，直接用二分插入排序算法</li>
<li>找到各个run，并入栈</li>
<li>按规则合并ru</li>
</ul>
<h4 id="Timsort性能"><a href="#Timsort性能" class="headerlink" title="Timsort性能"></a>Timsort性能</h4><p>在平均情况下，比较排序不会比O(n log n)更快。由于Timsort算法利用了现实中大多数数据中会有一些排好序的区，所以Timsort会比O(n log n)快些。对于随机数没有可以利用的排好序的区，Timsort时间复杂度会是log(n!)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlygodsee.github.io/2020/09/01/article-39/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog_head.png">
      <meta itemprop="name" content="涧石">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="太液池">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/article-39/" class="post-title-link" itemprop="url">线性排序</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-01 17:22:01" itemprop="dateCreated datePublished" datetime="2020-09-01T17:22:01+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 15:10:46" itemprop="dateModified" datetime="2020-09-03T15:10:46+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="线性排序"><a href="#线性排序" class="headerlink" title="线性排序"></a>线性排序</h2><p>桶排序、计数排序、基数排序。因为这些排序算法的时间复杂度是线性的，所以我们把这类排序算法叫作线性排序。</p>
<h3 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(arrays)</span>:</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line">    bucket_num = <span class="number">5</span></span><br><span class="line">    min_num = arrays[<span class="number">0</span>]</span><br><span class="line">    max_num = arrays[<span class="number">0</span>]</span><br><span class="line">    output = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">        <span class="keyword">if</span> arrays[i] &lt; min_num:</span><br><span class="line">            min_num = arrays[i]</span><br><span class="line">        <span class="keyword">elif</span> arrays[i] &gt; max_num:</span><br><span class="line">            max_num = arrays[i]</span><br><span class="line"></span><br><span class="line">    buckets_size = (max_num - min_num + <span class="number">1</span>) // bucket_num</span><br><span class="line">    bucket_lists = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(buckets_size)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> arrays:</span><br><span class="line">        idx = (num-min_num) // buckets_size</span><br><span class="line">        bucket_lists[idx].append(num)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> bucket_lists:</span><br><span class="line">      	<span class="comment"># 使用快排对桶内数组进行排序</span></span><br><span class="line">        quick_sort(bucket, <span class="number">0</span>, len(bucket)<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> bucket_lists:</span><br><span class="line">        output.extend(i)</span><br><span class="line"></span><br><span class="line">    print(output)</span><br></pre></td></tr></table></figure>

<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>桶排序比较<strong><em>适合用在外部排序中</em></strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p>
<h3 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>一种特殊的桶排序。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。</p>
<h4 id="“计数”的含义"><a href="#“计数”的含义" class="headerlink" title="“计数”的含义"></a>“计数”的含义</h4><p>利用另一个数组C记录小于等于当前桶值的数量，然后倒序遍历待排序数组A，然后根据数组C中对应的值确定当前值的位置，最后数组C对应数量减一，直至为零，往复循环。</p>
<h4 id="局限性-1"><a href="#局限性-1" class="headerlink" title="局限性"></a>局限性</h4><p>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</p>
<h3 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h3><p>以手机号排序为例（长度一致），需从末尾开始遍历然后递进排序。</p>
<h4 id="局限性-2"><a href="#局限性-2" class="headerlink" title="局限性"></a>局限性</h4><p>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>桶排序和计数排序的排序思想是非常相似的，都是针对范围不大的数据，将数据划分成不同的桶来实现排序。基数排序要求数据可以划分成高低位，位之间有递进关系。比较两个数，我们只需要比较高位，高位相同的再比较低位。而且每一位的数据范围不能太大，因为基数排序算法需要借助桶排序或者计数排序来完成每一个位的排序工作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlygodsee.github.io/2020/09/01/article-38/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog_head.png">
      <meta itemprop="name" content="涧石">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="太液池">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/article-38/" class="post-title-link" itemprop="url">排序（下）- 归并和快排</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-01 14:23:48" itemprop="dateCreated datePublished" datetime="2020-09-01T14:23:48+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 15:10:46" itemprop="dateModified" datetime="2020-09-03T15:10:46+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="归并排序（Merge-Sort）"><a href="#归并排序（Merge-Sort）" class="headerlink" title="归并排序（Merge Sort）"></a>归并排序（Merge Sort）</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。利用分治法的思想，和递归的编程技巧。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(arrays, l, mid, r)</span>:</span></span><br><span class="line">    output = []</span><br><span class="line">    i = l</span><br><span class="line">    j = mid + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt;= mid <span class="keyword">and</span> j &lt;= r:</span><br><span class="line">        <span class="keyword">if</span> arrays[i] &lt;= arrays[j]:</span><br><span class="line">            output.append(arrays[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            output.append(arrays[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> arrays[i:mid+<span class="number">1</span>] + arrays[j:r+<span class="number">1</span>]:</span><br><span class="line">        output.append(k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(len(output)):</span><br><span class="line">        arrays[l+idx] = output[idx]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergesort</span><span class="params">(arrays, l, r)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        mid = l + ((r - l) &gt;&gt; <span class="number">1</span>)</span><br><span class="line">        mergesort(arrays, l, mid)</span><br><span class="line">        mergesort(arrays, mid + <span class="number">1</span>, r)</span><br><span class="line">        merge(arrays, l, mid, r)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(arrays, arr1, arr2)</span>:</span></span><br><span class="line">    i = j = <span class="number">0</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i+j&lt;length:</span><br><span class="line">        <span class="keyword">if</span> j == len(arr2) <span class="keyword">or</span> (i &lt; len(arr1) <span class="keyword">and</span> arr1[i] &lt;= arr2[j]):</span><br><span class="line">            arrays[i+j] = arr1[i]</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            arrays[i+j] = arr2[j]</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(arrays)</span>:</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arrays</span><br><span class="line"></span><br><span class="line">    mid = length // <span class="number">2</span></span><br><span class="line">    arr1 = arrays[:mid]</span><br><span class="line">    arr2 = arrays[mid:]</span><br><span class="line"></span><br><span class="line">    merge_sort(arr1)</span><br><span class="line">    merge_sort(arr2)</span><br><span class="line"></span><br><span class="line">    merge(arrays, arr1, arr2)</span><br></pre></td></tr></table></figure>

<h4 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h4><h6 id="构造合理的merge函数，可以使得归并排序成为稳定排序"><a href="#构造合理的merge函数，可以使得归并排序成为稳定排序" class="headerlink" title="构造合理的merge函数，可以使得归并排序成为稳定排序"></a>构造合理的merge函数，可以使得归并排序成为稳定排序</h6><h6 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h6><p>设b，c是a的子问题，由此可得到一下公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(a) &#x3D; T(b) + T(c) + K</span><br><span class="line"># 其中 K 等于将两个子问题 b、c 的结果合并成问题 a 的结果所消耗的时间</span><br></pre></td></tr></table></figure>

<p>可以得到一个重要的结论：<strong><em>不仅递归求解的问题可以写成递推公式，递归代码的时间复杂度也可以写成递推公式</em></strong>。</p>
<p>最终递推公式为：<strong><em>T(n) = 2^kT(n/2^k)+kn</em></strong></p>
<p>所以，<strong><em>归并排序的时间复杂度为nlogn</em></strong></p>
<h6 id="空间复杂度O-n"><a href="#空间复杂度O-n" class="headerlink" title="空间复杂度O(n)"></a>空间复杂度O(n)</h6><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的。</p>
<p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据都有序了。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 快速排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arrays, l, r)</span>:</span></span><br><span class="line">    val = arrays[r]</span><br><span class="line">    idx = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(l, r):</span><br><span class="line">        <span class="keyword">if</span> arrays[i] &lt;= val:</span><br><span class="line">            idx += <span class="number">1</span></span><br><span class="line">            arrays[idx], arrays[i] = arrays[i], arrays[idx]</span><br><span class="line"></span><br><span class="line">    arrays[idx+<span class="number">1</span>], arrays[r] = arrays[r], arrays[idx+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> idx+<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arrays, l, r)</span>:</span></span><br><span class="line">    <span class="comment"># 分区区间小于1时退出</span></span><br><span class="line">    <span class="keyword">if</span> l&lt;r:</span><br><span class="line">        idx = partition(arrays, l, r)</span><br><span class="line">        quick_sort(arrays, l, idx<span class="number">-1</span>)</span><br><span class="line">        quick_sort(arrays, idx+<span class="number">1</span>, r)</span><br></pre></td></tr></table></figure>

<h4 id="与归并排序区别"><a href="#与归并排序区别" class="headerlink" title="与归并排序区别"></a>与归并排序区别</h4><p>归并排序的处理过程是<strong><em>由下到上</em></strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong><em>由上到下</em></strong>的，先分区，然后再处理子问题。</p>
<h4 id="性能分析-1"><a href="#性能分析-1" class="headerlink" title="性能分析"></a>性能分析</h4><p>最坏时间复杂度O(n^2)，平均复杂度O(nlogn)</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)。</p>
<p>快速排序算法虽然最坏情况下的时间复杂度是 O(n2)，但是平均情况下时间复杂度都是 O(nlogn)。不仅如此，快速排序算法时间复杂度退化到 O(n2) 的概率非常小，我们可以通过合理地选择 pivot 来避免这种情况。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlygodsee.github.io/2020/09/01/article-37/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog_head.png">
      <meta itemprop="name" content="涧石">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="太液池">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/01/article-37/" class="post-title-link" itemprop="url">排序（上）- 冒泡、插入和选择</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-01 10:50:35" itemprop="dateCreated datePublished" datetime="2020-09-01T10:50:35+08:00">2020-09-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 15:10:46" itemprop="dateModified" datetime="2020-09-03T15:10:46+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>最经典的、最常用的：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。</p>
<h3 id="分为三类"><a href="#分为三类" class="headerlink" title="分为三类"></a>分为三类</h3><h4 id="冒泡排序、插入排序、选择排序"><a href="#冒泡排序、插入排序、选择排序" class="headerlink" title="冒泡排序、插入排序、选择排序"></a>冒泡排序、插入排序、选择排序</h4><p>时间复杂度O(n^2), 基于比较</p>
<h4 id="归并排序、快速排序"><a href="#归并排序、快速排序" class="headerlink" title="归并排序、快速排序"></a>归并排序、快速排序</h4><p>时间复杂度O(nlogn), 基于比较</p>
<h4 id="计数排序、基数排序、桶排序"><a href="#计数排序、基数排序、桶排序" class="headerlink" title="计数排序、基数排序、桶排序"></a>计数排序、基数排序、桶排序</h4><p>时间复杂度O(n), 不基于比较</p>
<h3 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h3><h4 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h4><h6 id="最好情况、最坏情况、平均情况时间复杂度"><a href="#最好情况、最坏情况、平均情况时间复杂度" class="headerlink" title="最好情况、最坏情况、平均情况时间复杂度"></a>最好情况、最坏情况、平均情况时间复杂度</h6><h6 id="时间复杂度的系数、常数-、低阶"><a href="#时间复杂度的系数、常数-、低阶" class="headerlink" title="时间复杂度的系数、常数 、低阶"></a>时间复杂度的系数、常数 、低阶</h6><h6 id="比较次数和交换（或移动）次数"><a href="#比较次数和交换（或移动）次数" class="headerlink" title="比较次数和交换（或移动）次数"></a>比较次数和交换（或移动）次数</h6><h4 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h4><p>我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p>
<h4 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h4><p>这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
<h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">arrays = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(arrays)</span>:</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arrays</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(length-i<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> arrays[j+<span class="number">1</span>] &lt; arrays[j]:</span><br><span class="line">                arrays[j+<span class="number">1</span>], arrays[j] = arrays[j], arrays[j+<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">    print(arrays)</span><br></pre></td></tr></table></figure>

<h6 id="冒泡排序是原地排序，空间复杂度为O-1"><a href="#冒泡排序是原地排序，空间复杂度为O-1" class="headerlink" title="冒泡排序是原地排序，空间复杂度为O(1)"></a>冒泡排序是原地排序，空间复杂度为O(1)</h6><h6 id="当相邻两元素相等时不做交换时为稳定排序"><a href="#当相邻两元素相等时不做交换时为稳定排序" class="headerlink" title="当相邻两元素相等时不做交换时为稳定排序"></a>当相邻两元素相等时不做交换时为稳定排序</h6><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>最好时间复杂度为O(n), 最坏时间复杂度为O(n^2)</p>
<h5 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h5><p>又称加权平均期望复杂度。</p>
<p>如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我这里还有一种思路，通过“<strong><em>有序度</em></strong>”和“<strong><em>逆序度</em></strong>”这两个概念来进行分析。</p>
<p><strong><em>有序度</em></strong>是数组中具有有序关系的元素对的个数。其数学表达式为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;&#x3D; a[j], 如果i &lt; j。</span><br></pre></td></tr></table></figure>

<p>完全有序的数组，其有序度为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n(n-1) &#x2F; 2</span><br></pre></td></tr></table></figure>

<p>完全有序的数组的有序度叫作<strong><em>满有序度</em></strong></p>
<p>逆序度的定义正好跟有序度相反。</p>
<p>三者的关系</p>
<p><strong><em>满有序度 = 有序度 + 逆序度</em></strong></p>
<p>我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了。</p>
<p>所以冒泡排序的平均时间复杂度为O(n^2)</p>
<h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">arrays = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertionsort</span><span class="params">(arrays)</span>:</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> length &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arrays</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, length):</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        val = arrays[i]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> arrays[j] &gt; val:</span><br><span class="line">            arrays[j+<span class="number">1</span>] = arrays[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        arrays[j+<span class="number">1</span>] = val</span><br><span class="line"></span><br><span class="line">    print(arrays)</span><br></pre></td></tr></table></figure>

<h6 id="冒泡排序是原地排序，空间复杂度为O-1-1"><a href="#冒泡排序是原地排序，空间复杂度为O-1-1" class="headerlink" title="冒泡排序是原地排序，空间复杂度为O(1)"></a>冒泡排序是原地排序，空间复杂度为O(1)</h6><h6 id="当相邻两元素相等时不做交换时为稳定排序-1"><a href="#当相邻两元素相等时不做交换时为稳定排序-1" class="headerlink" title="当相邻两元素相等时不做交换时为稳定排序"></a>当相邻两元素相等时不做交换时为稳定排序</h6><h6 id="最好时间复杂度O-n-最坏时间复杂度O-n-2-平均时间复杂度O-n-2"><a href="#最好时间复杂度O-n-最坏时间复杂度O-n-2-平均时间复杂度O-n-2" class="headerlink" title="最好时间复杂度O(n), 最坏时间复杂度O(n^2), 平均时间复杂度O(n^2)"></a>最好时间复杂度O(n), 最坏时间复杂度O(n^2), 平均时间复杂度O(n^2)</h6><h3 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selectionsort</span><span class="params">(arrays)</span>:</span></span><br><span class="line">    length = len(arrays)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> len(arrays) &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> arrays</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        min_val = arrays[i]</span><br><span class="line">        min_idx = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>, length):</span><br><span class="line">            <span class="keyword">if</span> arrays[j] &lt; min_val:</span><br><span class="line">                min_val = arrays[j]</span><br><span class="line">                min_idx = j</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> min_idx != i:</span><br><span class="line">            arrays[i], arrays[min_idx] = arrays[min_idx], arrays[i]</span><br><span class="line"></span><br><span class="line">    print(arrays)</span><br></pre></td></tr></table></figure>

<h6 id="空间复杂度-O-1"><a href="#空间复杂度-O-1" class="headerlink" title="空间复杂度 O(1)"></a>空间复杂度 O(1)</h6><h6 id="不稳定排序"><a href="#不稳定排序" class="headerlink" title="不稳定排序"></a>不稳定排序</h6><h6 id="最好时间复杂度O-n-2-最坏时间复杂度O-n-2-，平均时间复杂度O-n-2"><a href="#最好时间复杂度O-n-2-最坏时间复杂度O-n-2-，平均时间复杂度O-n-2" class="headerlink" title="最好时间复杂度O(n^2), 最坏时间复杂度O(n^2)，平均时间复杂度O(n^2)"></a>最好时间复杂度O(n^2), 最坏时间复杂度O(n^2)，平均时间复杂度O(n^2)</h6><h3 id="为什么插入排序要比冒泡排序更受欢迎呢"><a href="#为什么插入排序要比冒泡排序更受欢迎呢" class="headerlink" title="为什么插入排序要比冒泡排序更受欢迎呢"></a>为什么插入排序要比冒泡排序更受欢迎呢</h3><p>因为冒泡排序需要两个位置进行数据交换，对于C语言这种就需要三个变量进行操作；但插入排序，只需要将数据后移，可以省略交换的操作。假设赋值语句时时间是K，那么冒泡排序需要的就是3K，而插入排序就是K，差距显而易见。</p>
<p>另外，<strong><em>希尔排序</em></strong> 是对插入排序的优化。</p>
<h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>冒泡、插入和选择对于小规模数据非常高效，但当数据规模很大时，就不再适用了。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？"><a href="#数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？" class="headerlink" title="数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？"></a>数据存储在链表中，这三种排序算法还能工作吗？如果能，那相应的时间、空间复杂度又是多少呢？</h4><p>考虑只能改变节点位置，冒泡排序相比于数组实现，比较次数一致，但交换时操作更复杂；插入排序，比较次数一致，不需要再有后移操作，找到位置后可以直接插入，但排序完毕后可能需要倒置链表；选择排序比较次数一致，交换操作同样比较麻烦。综上，时间复杂度和空间复杂度并无明显变化，若追求极致性能，冒泡排序的时间复杂度系数会变大，插入排序系数会减小，选择排序无明显变化。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://onlygodsee.github.io/2020/08/31/article-36/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/blog_head.png">
      <meta itemprop="name" content="涧石">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="太液池">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/31/article-36/" class="post-title-link" itemprop="url">递归</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-08-31 18:53:20" itemprop="dateCreated datePublished" datetime="2020-08-31T18:53:20+08:00">2020-08-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-03 15:10:46" itemprop="dateModified" datetime="2020-09-03T15:10:46+08:00">2020-09-03</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" itemprop="url" rel="index"><span itemprop="name">数据结构与算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h3><p>去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。</p>
<h3 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h3><h4 id="1、一个问题的解可以分解为几个子问题的解"><a href="#1、一个问题的解可以分解为几个子问题的解" class="headerlink" title="1、一个问题的解可以分解为几个子问题的解"></a>1、一个问题的解可以分解为几个子问题的解</h4><p>子问题就是数据规模更小的问题。</p>
<h4 id="2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"><a href="#2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样" class="headerlink" title="2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样"></a>2、这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</h4><h4 id="3、存在递归终止条件"><a href="#3、存在递归终止条件" class="headerlink" title="3、存在递归终止条件"></a>3、存在递归终止条件</h4><p>跳出无限循环的条件</p>
<h3 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h3><p>关键的是<strong><em>写出递推公式，找到终止条件</em></strong></p>
<p><strong><em>总体思路</em></strong>：找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p>
<p>遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p>
<h3 id="警惕点"><a href="#警惕点" class="headerlink" title="警惕点"></a>警惕点</h3><h4 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h4><p>每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p>
<h4 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h4><p>为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)</p>
<h3 id="台阶问题"><a href="#台阶问题" class="headerlink" title="台阶问题"></a>台阶问题</h3><p>假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2，2，2，1 这样子上去，也可以 1，2，1，1，2 这样子上去，总之走法有很多，那如何用编程求得总共有多少种走法呢？</p>
<h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FootstepCountNew</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    优化重复计算</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.mykeys = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> n <span class="keyword">in</span> self.mykeys:</span><br><span class="line">            <span class="keyword">return</span> self.mykeys[n]</span><br><span class="line"></span><br><span class="line">        result = self.run(n<span class="number">-1</span>) + self.run(n<span class="number">-2</span>)</span><br><span class="line">        self.mykeys[n] = result</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>

<h4 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(n)</span>:</span></span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    output = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        b, a = a+b, b</span><br><span class="line">        output.append(b)</span><br><span class="line"></span><br><span class="line">    print(output)</span><br><span class="line">    print(b)</span><br></pre></td></tr></table></figure>



<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><h4 id="我们平时调试代码喜欢使用-IDE-的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？"><a href="#我们平时调试代码喜欢使用-IDE-的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？" class="headerlink" title="我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？"></a>我们平时调试代码喜欢使用 IDE 的单步跟踪功能，像规模比较大、递归层次很深的递归代码，几乎无法使用这种调试方式。对于递归代码，你有什么好的调试方法呢？</h4><ul>
<li>打印日志发现，递归值。</li>
<li>结合条件断点进行调试。</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="涧石"
      src="/images/blog_head.png">
  <p class="site-author-name" itemprop="name">涧石</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">42</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/onlygodsee" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;onlygodsee" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">涧石</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>

